# 课程安排

## 并发编程(3~4d)

## 小项目(2~3d)

## 数据库(MySQL) 5d

## 前端7d

## django框架(10d)

## bbs项目(3~5d)

## 代码发布(5d)

## CMDB(5d)



# 自我介绍

讲师姓名:Jason、鸡哥

身高:183

体重:75KG

# 学习建议

* 要懂得取舍，没必要所有的知识都啃的很透

  ```python
  """这个东西是什么，能用来干嘛，怎么用"""
  ```

* 一定要培养自我解决问题的能力

  ```python
  """
  遇到一个问题之后一定要先给自己设置一个解决改问题的时间限
  30分钟之内我自己解决
  	百度
  30分钟到一个小时问朋友，同学
  	讨论
  一个小时以上
  	问老师
  """
  ```

# 格言 

* #### 20岁超越30岁、40岁、50岁人的成就

* #### 衣锦还乡

* #### 技多不压身

  知识面的宽度，暂时先不要考虑深度

  先学知识的基本概念，哪怕概念不是很正确，但是能够帮助你快速理解



# 并发编程

并发编程理论居多，实际应用代码很简单

我们在听的时候不要有太大的压力，听明白理论即可

# 今日内容

* 操作系统发展史
* 多道技术
* 进程理论
* 开启进程的两种方式
* 进程对象的join方法
* 进程之间数据相互隔离
* 进程对象的其他方法
* 僵尸进程与孤儿进程
* 守护进程
* 互斥锁

# 必备知识回顾

* 计算机又叫电脑，即通电的大脑，发明计算机是为了让他通电之后能够像人一样去工作，并且它比人的工作效率更高，因为可以24小时不间断

* 计算机五大组成部分

  控制器

  运算器

  存储器

  输入设备

  输出设备

  计算机的核心真正干活的是CPU(控制器+运算器=中央处理器)

* 程序要想被计算机运行，它的代码必须要先由硬盘读到内存，之后cpu取指再执行

  

# 今日内容详细

## 操作系统发展史

参考博客即可:<https://www.cnblogs.com/Dominic-Ji/articles/10929381.html>

## 多道技术

单核实现并发的效果

#### 必备知识点

* 并发

  看起来像同时运行的就可以称之为并发

* 并行

  真正意义上的同时执行

ps:

* 并行肯定算并发
* 单核的计算机肯定不能实现并行，但是可以实现并发！！！

补充：我们直接假设单核就是一个核，干活的就一个人，不要考虑cpu里面的内核数

#### 多道技术图解

节省多个程序运行的总耗时

参考群内截图

#### 多道技术重点知识

空间上的服用与时间上的服用

* 空间上的复用

  多个程序公用一套计算机硬件

* 时间上的复用

  例子:洗衣服30s，做饭50s，烧水30s

  单道需要110s，多道只需要任务做长的那一个 		切换节省时间

  例子:边吃饭边玩游戏							   保存状态

切换+保存状态

```python
"""
切换(CPU)分为两种情况
	1.当一个程序遇到IO操作的时候，操作系统会剥夺该程序的CPU执行权限
		作用:提高了CPU的利用率 并且也不影响程序的执行效率
	
	2.当一个程序长时间占用CPU的时候，操作吸引也会剥夺该程序的CPU执行权限
		弊端:降低了程序的执行效率(原本时间+切换时间)
"""
```

# 进程理论

### 必备知识点

程序与进程的区别

```python
"""
程序就是一堆躺在硬盘上的代码，是“死”的
进程则表示程序正在执行的过程，是“活”的
"""
```

### 进程调度

* 先来先服务调度算法

  ```python
  """对长作业有利，对短作业无益"""
  ```

* 短作业优先调度算法

  ```python
  """对短作业有利，多长作业无益"""
  ```

* 时间片轮转法+多级反馈队列

  参考图解

### 进程运行的三状态图

参考图解了解即可

### 两对重要概念

* **同步和异步**

  ```python
  """描述的是任务的提交方式"""
  同步:任务提交之后，原地等待任务的返回结果，等待的过程中不做任何事(干等)
    	程序层面上表现出来的感觉就是卡住了
  
  异步:任务提交之后，不原地等待任务的返回结果，直接去做其他事情
    	我提交的任务结果如何获取？
      任务的返回结果会有一个异步回调机制自动处理
  ```

* **阻塞非阻塞**

  ```python
  """描述的程序的运行状态"""
  阻塞:阻塞态
  非阻塞:就绪态、运行态
  
  理想状态:我们应该让我们的写的代码永远处于就绪态和运行态之间切换
  ```

上述概念的组合:最高效的一种组合就是**异步非阻塞**

## 开启进程的两种方式

定心丸:代码开启进程和线程的方式，代码书写基本是一样的，你学会了如何开启进程就学会了如何开启线程

```PYTHON
from multiprocessing import Process
import time


def task(name):
    print('%s is running'%name)
    time.sleep(3)
    print('%s is over'%name)


if __name__ == '__main__':
    # 1 创建一个对象
    p = Process(target=task, args=('jason',))
    # 容器类型哪怕里面只有1个元素 建议要用逗号隔开
    # 2 开启进程
    p.start()  # 告诉操作系统帮你创建一个进程  异步
    print('主')
    
    
# 第二种方式 类的继承
from multiprocessing import Process
import time


class MyProcess(Process):
    def run(self):
        print('hello bf girl')
        time.sleep(1)
        print('get out!')


if __name__ == '__main__':
    p = MyProcess()
    p.start()
    print('主')
```

**总结**

```python
"""
创建进程就是在内存中申请一块内存空间将需要运行的代码丢进去
一个进程对应在内存中就是一块独立的内存空间
多个进程对应在内存中就是多块独立的内存空间
进程与进程之间数据默认情况下是无法直接交互,如果想交互可以借助于第三方工具、模块
"""
```

## join方法

join是让主进程等待子进程代码运行结束之后，再继续运行。不影响其他子进程的执行

```python
from multiprocessing import Process
import time


def task(name, n):
    print('%s is running'%name)
    time.sleep(n)
    print('%s is over'%name)


if __name__ == '__main__':
    # p1 = Process(target=task, args=('jason', 1))
    # p2 = Process(target=task, args=('egon', 2))
    # p3 = Process(target=task, args=('tank', 3))
    # start_time = time.time()
    # p1.start()
    # p2.start()
    # p3.start()  # 仅仅是告诉操作系统要创建进程
    # # time.sleep(50000000000000000000)
    # # p.join()  # 主进程等待子进程p运行结束之后再继续往后执行
    # p1.join()
    # p2.join()
    # p3.join()
    start_time = time.time()
    p_list = []
    for i in range(1, 4):
        p = Process(target=task, args=('子进程%s'%i, i))
        p.start()
        p_list.append(p)
    for p in p_list:
        p.join()
    print('主', time.time() - start_time)
```

## 进程之间数据相互隔离

```python
from multiprocessing import Process


money = 100


def task():
    global money  # 局部修改全局
    money = 666
    print('子',money)


if __name__ == '__main__':
    p = Process(target=task)
    p.start()
    p.join()
    print(money)
```

# 今日作业

**必做题**

* 简述操作系统发展史
* 简述进程发展史及算法演变
* 简述多道技术
* 简述同步异步阻塞非阻塞概念
* 书写进程创建的两种方式
* 将具体内容整理到博客中

**选做题**

* 计算机硬件知识扩展(感兴趣)
* 数据分析算法学习资料收集(感兴趣)





























